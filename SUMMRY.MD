â€‹	å…¶å®çœ‹ä¸‹æ¥ï¼Œæ€»çš„åŸç†è¿˜è›®ç®€å•çš„ã€‚è·Ÿserveräº¤äº’åŸºæœ¬æµç¨‹ï¼šå°è£…cmd(åŒ…å«å‘½ä»¤å’Œå¯¹åº”å€¼çš„ä¿¡æ¯) -> æŒ‰ç…§redisåè®®æ¥å°è£…è¿™ä¸ªcmdçš„ä¿¡æ¯ï¼ŒåŸºæœ¬æ ¼å¼éƒ½æ˜¯å›ºå®šçš„å•¦ -> é€šè¿‡connå‘é€å°è£…å¥½çš„æ•°æ® -> å¾—åˆ°è¿”å›åæŒ‰ç…§redisåè®®è¿›è¡Œè§£æ -> è¿”å›cmdï¼Œè¯»å–cmdçš„valå¾—åˆ°ç»“æœ

â€‹	çœ‹ğŸ‘‡ğŸ»å§ï¼ŒåŸºæœ¬éƒ½æ˜¯è¿™ä¸ªbæ ·ï¼Œç»„è£…cmdï¼Œç„¶åè°ƒç”¨c

<img src="/Users/chb/Library/Application Support/typora-user-images/image-20230605224454721.png" alt="image-20230605224454721" style="zoom:50%;" />

â€‹	è¿™ä¸ªcçš„æ–¹æ³•å®šä¹‰ï¼Œå…¶å†…éƒ¨è°ƒç”¨çš„æ˜¯processæ–¹æ³•ã€‚å½“ç„¶å•¦ï¼Œåœ¨redis-cliä¸­è¿™ä¸ªprocesså…¶å®æ˜¯è¢«å¾ˆå¤šä¸ªä¸­é—´ä»¶(hook)åŒ…èµ·æ¥çš„ï¼Œhookæ‰§è¡Œå®Œæ‰æ‰§è¡Œprocessï¼Œæˆ–è€…hookä¹Ÿå¯ä»¥æ§åˆ¶processçš„æ‰§è¡Œ

â€‹	æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œprocessä¸­å…¶å®æ˜¯è°ƒç”¨äº†\_processå•¦ï¼Œè€Œprocessè´Ÿè´£æ¥æ§åˆ¶é‡è¯•æ“ä½œã€‚æ¥åˆ°\_processä¸­ï¼Œå¯ä»¥çœ‹åˆ°å®ƒè°ƒç”¨äº†WithWriterå’ŒWithReaderä¸¤ä¸ªæ–¹æ³•ï¼Œå‰ä¸€ä¸ªå°±æ˜¯å†™å‘½ä»¤ç»™redisServerå•¦ï¼Œåä¸€ä¸ªå°±æ˜¯è¯»å–serverçš„å“åº”å†…å®¹ï¼Œå½“ç„¶ï¼Œè¿™ä¸¤ä¸ªæ–¹æ³•éƒ½åŒ…å«äº†ä¸€å †çš„åè®®å°è£…å’Œè½¬åŒ–ï¼Œè¿™ä¸ªæ„Ÿå…´è¶£çš„å¯ä»¥ç»†çœ‹æ–¹æ³•å“ˆ

â€‹	é‚£å…¶å®go-redis-cliçš„æ‰€æœ‰æ–¹æ³•åŸºæœ¬éƒ½æ˜¯å›´ç»•Processæ¥æçš„ï¼Œæ‰€ä»¥ä¹Ÿæ²¡æœ‰å•¥å¤§å¥½çœ‹çš„å•¦

```go
func (c *Client) Process(ctx context.Context, cmd Cmder) error {
	err := c.processHook(ctx, cmd)
	cmd.SetErr(err)
	return err
}

// NOTE redis-clientä¸­æœ€å…³é”®çš„æ–¹æ³•
func (c *baseClient) process(ctx context.Context, cmd Cmder) error {
	var lastErr error
	for attempt := 0; attempt <= c.opt.MaxRetries; attempt++ {
		attempt := attempt

		retry, err := c._process(ctx, cmd, attempt)
		if err == nil || !retry {
			return err
		}

		lastErr = err
	}
	return lastErr
}

// NOTE å…³é”®æ–¹æ³•ï¼Œä¸»è¦æ˜¯å°†cmdæŒ‰redisåè®®ç»„ç»‡åå†™å…¥connï¼Œå†å°†ç›¸åº”çš„å†…å®¹æŒ‰åè®®è¯»å–å‡ºæ¥ï¼Œç»“æœéƒ½å¡åˆ°cmdçš„valä¸­å»
func (c *baseClient) _process(ctx context.Context, cmd Cmder, attempt int) (bool, error) {
	// é‡è¯•ä¹‹é—´éœ€è¦æœ‰ä¸€å®šçš„æ—¶é—´é—´éš”ï¼Œè¿™é‡Œæ ¹æ®retryBackoffæ¥è®¡ç®—
	if attempt > 0 {
		if err := internal.Sleep(ctx, c.retryBackoff(attempt)); err != nil {
			return false, err
		}
	}

	retryTimeout := uint32(0)

	if err := c.withConn(ctx, func(ctx context.Context, cn *pool.Conn) error { // å–connï¼Œè°ƒfunc(ctx context.Context, cn *pool.Conn)
		if err := cn.WithWriter(c.context(ctx), c.opt.WriteTimeout, // å¤„ç†Deadlineç›¸å…³ï¼Œå¹¶åˆ·æ–°writeCmdçš„å†™å…¥
			func(wr *proto.Writer) error {
				return writeCmd(wr, cmd) // æŒ‰ç…§redisåè®®ç»„ç»‡argså¹¶è¿›è¡Œå†™å…¥
			}); err != nil {
			atomic.StoreUint32(&retryTimeout, 1)
			return err
		}
		// TODO readReplyæ–¹æ³•è¿˜æ²¡çœ‹
		if err := cn.WithReader(c.context(ctx), c.cmdTimeout(cmd), cmd.readReply); err != nil { // å¤„ç†è¶…æ—¶ç›¸å…³ï¼Œå†è°ƒç”¨readReply
			if cmd.readTimeout() == nil {
				atomic.StoreUint32(&retryTimeout, 1)
			} else {
				atomic.StoreUint32(&retryTimeout, 0)
			}
			return err
		}

		return nil
	}); err != nil {
		retry := shouldRetry(err, atomic.LoadUint32(&retryTimeout) == 1)
		return retry, err
	}

	return false, nil
}
```

